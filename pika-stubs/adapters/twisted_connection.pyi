import pika.connection
from collections import namedtuple
from pika import exceptions as exceptions, spec as spec
from pika.adapters.utils import nbio_interface as nbio_interface
from pika.adapters.utils.io_services_utils import check_callback_arg as check_callback_arg
from twisted.internet import defer, protocol
from typing import Any, Optional

LOGGER: Any

class ClosableDeferredQueue(defer.DeferredQueue):
    closed: Any = ...
    def __init__(self, size: Optional[Any] = ..., backlog: Optional[Any] = ...) -> None: ...
    def put(self, obj: Any): ...
    def get(self): ...
    pending: Any = ...
    def close(self, reason: Any) -> None: ...

ReceivedMessage = namedtuple('ReceivedMessage', ['channel', 'method', 'properties', 'body'])

class TwistedChannel:
    on_closed: Any = ...
    def __init__(self, channel: Any) -> None: ...
    @property
    def channel_number(self): ...
    @property
    def connection(self): ...
    @property
    def is_closed(self): ...
    @property
    def is_closing(self): ...
    @property
    def is_open(self): ...
    @property
    def flow_active(self): ...
    @property
    def consumer_tags(self): ...
    def callback_deferred(self, deferred: Any, replies: Any) -> None: ...
    def add_on_return_callback(self, callback: Any): ...
    def basic_ack(self, delivery_tag: int = ..., multiple: bool = ...): ...
    def basic_cancel(self, consumer_tag: str = ...): ...
    def basic_consume(self, queue: Any, auto_ack: bool = ..., exclusive: bool = ..., consumer_tag: Optional[Any] = ..., arguments: Optional[Any] = ...): ...
    def basic_get(self, queue: Any, auto_ack: bool = ...): ...
    def basic_nack(self, delivery_tag: Optional[Any] = ..., multiple: bool = ..., requeue: bool = ...): ...
    def basic_publish(self, exchange: Any, routing_key: Any, body: Any, properties: Optional[Any] = ..., mandatory: bool = ...): ...
    def basic_qos(self, prefetch_size: int = ..., prefetch_count: int = ..., global_qos: bool = ...): ...
    def basic_reject(self, delivery_tag: Any, requeue: bool = ...): ...
    def basic_recover(self, requeue: bool = ...): ...
    def close(self, reply_code: int = ..., reply_text: str = ...): ...
    def confirm_delivery(self): ...
    def exchange_bind(self, destination: Any, source: Any, routing_key: str = ..., arguments: Optional[Any] = ...): ...
    def exchange_declare(self, exchange: Any, exchange_type: str = ..., passive: bool = ..., durable: bool = ..., auto_delete: bool = ..., internal: bool = ..., arguments: Optional[Any] = ...): ...
    def exchange_delete(self, exchange: Optional[Any] = ..., if_unused: bool = ...): ...
    def exchange_unbind(self, destination: Optional[Any] = ..., source: Optional[Any] = ..., routing_key: str = ..., arguments: Optional[Any] = ...): ...
    def flow(self, active: Any): ...
    def open(self): ...
    def queue_bind(self, queue: Any, exchange: Any, routing_key: Optional[Any] = ..., arguments: Optional[Any] = ...): ...
    def queue_declare(self, queue: Any, passive: bool = ..., durable: bool = ..., exclusive: bool = ..., auto_delete: bool = ..., arguments: Optional[Any] = ...): ...
    def queue_delete(self, queue: Any, if_unused: bool = ..., if_empty: bool = ...): ...
    def queue_purge(self, queue: Any): ...
    def queue_unbind(self, queue: Any, exchange: Optional[Any] = ..., routing_key: Optional[Any] = ..., arguments: Optional[Any] = ...): ...
    def tx_commit(self): ...
    def tx_rollback(self): ...
    def tx_select(self): ...

class _TwistedConnectionAdapter(pika.connection.Connection):
    def __init__(self, parameters: Any, on_open_callback: Any, on_open_error_callback: Any, on_close_callback: Any, custom_reactor: Any) -> None: ...
    def connection_made(self, transport: Any) -> None: ...
    def connection_lost(self, error: Any) -> None: ...
    def data_received(self, data: Any) -> None: ...

class TwistedProtocolConnection(protocol.Protocol):
    ready: Any = ...
    closed: Any = ...
    def __init__(self, parameters: Optional[Any] = ..., custom_reactor: Optional[Any] = ...): ...
    def channel(self, channel_number: Optional[Any] = ...): ...
    @property
    def is_closed(self): ...
    def close(self, reply_code: int = ..., reply_text: str = ...): ...
    def dataReceived(self, data: Any) -> None: ...
    def connectionLost(self, reason: Any = ...) -> None: ...
    def makeConnection(self, transport: Any) -> None: ...
    def connectionReady(self) -> None: ...

class _TimerHandle(nbio_interface.AbstractTimerReference):
    def __init__(self, handle: Any) -> None: ...
    def cancel(self) -> None: ...
